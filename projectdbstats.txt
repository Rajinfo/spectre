import os
import re
import csv

def read_in_chunks(file_object, chunk_size=1024):
    """Lazy function (generator) to read a file piece by piece."""
    while True:
        data = file_object.read(chunk_size)
        if not data:
            break
        yield data

def is_mybatis_or_ibatis(file_path):
    """Check if the XML file specifies MyBatis or iBATIS DTD."""
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read(3300)
        return ('<!DOCTYPE mapper' in content or '<!DOCTYPE sqlMap' in content)

def extract_objects_and_operations(file_path, is_xml=False):
    """Extract tables, procedures, views, triggers, and operations."""

    # SQL Patterns for table, procedures, views, etc.
    table_pattern = r'\b(?:FROM|JOIN|LEFT\s+JOIN|RIGHT\s+JOIN|INNER\s+JOIN|OUTER\s+JOIN|CROSS\s+JOIN|MERGE\s+INTO|UPDATE|DELETE\s+FROM|INTO)\s+([a-zA-Z0-9_\.]+)\s*(?:AS\s+)?([a-zA-Z0-9_]+)?'
    select_tag_pattern = r'<(select|update|insert|delete)\s+.*?>.*?</\1>'
    
    # Other patterns for various object types
    procedure_pattern = r'CREATE\s+OR\s+REPLACE\s+PROCEDURE\s+([a-zA-Z0-9_]+)\s*\('
    function_pattern = r'CREATE\s+OR\s+REPLACE\s+FUNCTION\s+([a-zA-Z0-9_]+)\s*\('
    view_pattern = r'CREATE\s+OR\s+REPLACE\s+VIEW\s+([a-zA-Z0-9_]+)'
    trigger_pattern = r'CREATE\s+(OR\s+REPLACE\s+)?TRIGGER\s+([a-zA-Z0-9_]+)\s+.*?\s+ON\s+([a-zA-Z0-9_]+)'

    objects_and_operations = []
    is_xml = file_path.endswith('.xml')
    content = []
    inside_sql_tag = False

    with open(file_path, 'r', encoding='utf-8') as file:
        if is_xml:
            inside_comment_block = False
            for chunk in read_in_chunks(file):
                chunk_lines = chunk.splitlines()
                for line in chunk_lines:
                    line = line.strip()

                    # Handle block comments in XML
                    if line.startswith('<!--'):
                        inside_comment_block = True
                    if inside_comment_block:
                        if '-->' in line:
                            inside_comment_block = False
                        continue

                    # Remove inline XML comments
                    line = re.sub(r'<!--.*?-->', '', line)

                    # Detect start of SQL tags <select>, <update>, <insert>, <delete> with 'id' attribute
                    if re.search(r'<(select|update|insert|delete)\s+[^>]*id\s*=', line, re.IGNORECASE):
                        inside_sql_tag = True
                        continue  # Skip the tag with 'id', but do not skip the SQL content

                    # Detect the end of the SQL tags
                    if inside_sql_tag and re.search(r'</(select|update|insert|delete)>', line, re.IGNORECASE):
                        inside_sql_tag = False
                        continue  # Skip the closing tag, but capture SQL before this

                    # Capture SQL content within tags
                    if inside_sql_tag:
                        content.append(line)

            # Find SQL queries within XML tags and capture table names
            xml_content = '\n'.join(content)
            for tag_match in re.findall(select_tag_pattern, xml_content, re.IGNORECASE | re.DOTALL):
                tag_content = re.search(r'>\s*(SELECT|INSERT|UPDATE|DELETE).*?<', xml_content, re.IGNORECASE | re.DOTALL)
                if tag_content:
                    # Extract tables within the SQL queries in XML
                    for match in re.findall(table_pattern, tag_content.group(0), re.IGNORECASE | re.DOTALL):
                        table_name = match[0]
                        objects_and_operations.append((table_name, 'Table', tag_match.lower()))

        else:
            # SQL file processing: remove inline SQL comments like -- and /* ... */
            for chunk in read_in_chunks(file):
                chunk = re.sub(r'--.*', '', chunk)
                chunk = re.sub(r'/\*.*?\*/', '', chunk, flags=re.DOTALL)
                content.append(chunk)

        # Rejoin the content for regex processing
        content = '\n'.join(content)

        # Search for triggers
        for match in re.findall(trigger_pattern, content, re.IGNORECASE | re.DOTALL):
            trigger_name = match[1]
            table_name = match[2]
            objects_and_operations.append((trigger_name, 'Trigger', 'create'))
            objects_and_operations.append((table_name, 'Table', 'trigger'))

        # Search for table-related operations
        for match in re.findall(table_pattern, content, re.IGNORECASE | re.DOTALL):
            table_name = match[0]
            objects_and_operations.append((table_name, 'Table', 'select' if 'from' in match[0].lower() else ''))

        # Other object searches
        for match in re.findall(procedure_pattern, content, re.IGNORECASE | re.DOTALL):
            objects_and_operations.append((match, 'PLSQL', 'create or replace procedure'))
        for match in re.findall(function_pattern, content, re.IGNORECASE | re.DOTALL):
            objects_and_operations.append((match, 'PLSQL', 'create or replace function'))
        for match in re.findall(view_pattern, content, re.IGNORECASE | re.DOTALL):
            objects_and_operations.append((match, 'View', 'create or replace view'))

    return objects_and_operations

def process_folders_from_csv(csv_file, output_csv):
    """Process folders listed in CSV, find MyBatis/iBATIS mapper and SQL files."""
    with open(csv_file, 'r', encoding='utf-8') as file:
        reader = csv.reader(file)
        folder_names = [row[0] for row in reader]

    # Write results
    with open(output_csv, 'w', newline='', encoding='utf-8') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['FolderName', 'FolderPath', 'FilePath', 'FileName', 'ObjectName', 'ObjectType', 'OperationType'])

        for folder in folder_names:
            for root, _, files in os.walk(folder):
                for file_name in files:
                    if file_name.endswith(('.xml', '.sql')):
                        file_path = os.path.join(root, file_name)
                        objects_and_operations = []

                        # Check if the XML is MyBatis or iBATIS
                        if file_name.endswith('.xml') and is_mybatis_or_ibatis(file_path):
                            objects_and_operations = extract_objects_and_operations(file_path, is_xml=True)
                        elif file_name.endswith('.sql'):
                            objects_and_operations = extract_objects_and_operations(file_path)

                        if objects_and_operations:
                            for object_name, object_type, operation_type in objects_and_operations:
                                writer.writerow([folder, root, file_path, file_name, object_name, object_type, operation_type])

# Example usage
csv_input = 'D:/program/test/file-db.csv'  # Replace with your CSV file containing folder names
csv_output = 'D:/program/test/out-reponsedb.csv'  # Output CSV file for folder and table names
process_folders_from_csv(csv_input, csv_output)

print("Table names extracted and saved to", csv_output)